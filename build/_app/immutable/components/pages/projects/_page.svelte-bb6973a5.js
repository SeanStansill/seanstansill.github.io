import{S as Yt,i as Ot,s as Ft,w as V,a as _,k as f,x as z,c as w,l as m,m as v,h as n,y as N,b as u,f as Y,t as O,z as F,a1 as Jt,q as c,r as p,n as gt,a7 as l,_ as Bt}from"../../../chunks/index-5f4f0251.js";import{P as kt,T as Et,C as Lt}from"../../../chunks/Subtitle-e1001e8a.js";import{B as Kt}from"../../../chunks/banner-c9a3ecf7.js";import{A as Wt}from"../../../chunks/author_profile-2005bf0a.js";import{i as Xt}from"../../../chunks/isDark-830880ff.js";function Zt(g){let i;return{c(){i=c("Projects")},l(a){i=p(a,"Projects")},m(a,s){u(a,i,s)},d(a){a&&n(i)}}}function te(g){let i;return{c(){i=c("This section contains notes on a few of my projects. You can find my open source projects can be found on my GitHub!")},l(a){i=p(a,"This section contains notes on a few of my projects. You can find my open source projects can be found on my GitHub!")},m(a,s){u(a,i,s)},d(a){a&&n(i)}}}function ee(g){let i,a,s,d;return i=new Et({props:{$$slots:{default:[Zt]},$$scope:{ctx:g}}}),s=new Lt({props:{$$slots:{default:[te]},$$scope:{ctx:g}}}),{c(){V(i.$$.fragment),a=_(),V(s.$$.fragment)},l(t){z(i.$$.fragment,t),a=w(t),z(s.$$.fragment,t)},m(t,r){N(i,t,r),u(t,a,r),N(s,t,r),d=!0},p(t,r){const I={};r&8&&(I.$$scope={dirty:r,ctx:t}),i.$set(I);const y={};r&8&&(y.$$scope={dirty:r,ctx:t}),s.$set(y)},i(t){d||(Y(i.$$.fragment,t),Y(s.$$.fragment,t),d=!0)},o(t){O(i.$$.fragment,t),O(s.$$.fragment,t),d=!1},d(t){F(i,t),t&&n(a),F(s,t)}}}function ne(g){let i;return{c(){i=c("Atomistic Spin Dynamics")},l(a){i=p(a,"Atomistic Spin Dynamics")},m(a,s){u(a,i,s)},d(a){a&&n(i)}}}function ie(g){let i,a,s,d,t,r,I,y,E,A,C,L,Q,D,q,U,e,h,G,R,P,x,K;return{c(){i=c(`Throughout my PhD I've been working on a closed-source atomistic spin dynamics code.
			It is a modern code, highly modular code which is optimized to run on GPUs. I've become
			an expert in scientific computing, algorithm design, and software optimization (among other
			things).`),a=f("br"),s=_(),d=f("br"),t=c(`
			I personally designed and implemented a new algorithm to calculate free energy differences which is
			highly parallelisable and optimized to run on GPUs. The new method required new science advances, and
			has over a thousand fold increase in performance over the previous state of the art. It pushes the 
			boundaries of atomistic modelling. The previous method (which can be found `),r=f("a"),I=c("here"),y=c(`)
			cannot be parallelised, and only works with Monte Carlo methods which have been largely replaced 
			by dynamical methods (see `),E=f("a"),A=c("here"),C=c(" for an example of why)."),L=f("br"),Q=_(),D=f("br"),q=c(`
			As well as low level programming, I use Python for data analysis. Visit 
			
			`),U=f("br"),e=_(),h=f("br"),G=c(`
			Below are some links to some mathematical derivations I've done during my PhD:
			`),R=f("ul"),P=f("li"),x=f("a"),K=c("Poisson summation of the discrete dipole interaction"),this.h()},l(o){i=p(o,`Throughout my PhD I've been working on a closed-source atomistic spin dynamics code.
			It is a modern code, highly modular code which is optimized to run on GPUs. I've become
			an expert in scientific computing, algorithm design, and software optimization (among other
			things).`),a=m(o,"BR",{}),s=w(o),d=m(o,"BR",{}),t=p(o,`
			I personally designed and implemented a new algorithm to calculate free energy differences which is
			highly parallelisable and optimized to run on GPUs. The new method required new science advances, and
			has over a thousand fold increase in performance over the previous state of the art. It pushes the 
			boundaries of atomistic modelling. The previous method (which can be found `),r=m(o,"A",{href:!0});var k=v(r);I=p(k,"here"),k.forEach(n),y=p(o,`)
			cannot be parallelised, and only works with Monte Carlo methods which have been largely replaced 
			by dynamical methods (see `),E=m(o,"A",{href:!0});var Z=v(E);A=p(Z,"here"),Z.forEach(n),C=p(o," for an example of why)."),L=m(o,"BR",{}),Q=w(o),D=m(o,"BR",{}),q=p(o,`
			As well as low level programming, I use Python for data analysis. Visit 
			
			`),U=m(o,"BR",{}),e=w(o),h=m(o,"BR",{}),G=p(o,`
			Below are some links to some mathematical derivations I've done during my PhD:
			`),R=m(o,"UL",{});var H=v(R);P=m(H,"LI",{});var tt=v(P);x=m(tt,"A",{href:!0});var et=v(x);K=p(et,"Poisson summation of the discrete dipole interaction"),et.forEach(n),tt.forEach(n),H.forEach(n),this.h()},h(){gt(r,"href","https://www-users.york.ac.uk/~rfle500/resources/paper_7.pdf"),gt(E,"href","https://eprints.whiterose.ac.uk/151412/1/quantum_thermodynamics_of_yig_merged.pdf"),gt(x,"href","/docs/NiOAnisotropyScalingDerivation.pdf")},m(o,k){u(o,i,k),u(o,a,k),u(o,s,k),u(o,d,k),u(o,t,k),u(o,r,k),l(r,I),u(o,y,k),u(o,E,k),l(E,A),u(o,C,k),u(o,L,k),u(o,Q,k),u(o,D,k),u(o,q,k),u(o,U,k),u(o,e,k),u(o,h,k),u(o,G,k),u(o,R,k),l(R,P),l(P,x),l(x,K)},p:Bt,d(o){o&&n(i),o&&n(a),o&&n(s),o&&n(d),o&&n(t),o&&n(r),o&&n(y),o&&n(E),o&&n(C),o&&n(L),o&&n(Q),o&&n(D),o&&n(q),o&&n(U),o&&n(e),o&&n(h),o&&n(G),o&&n(R)}}}function se(g){let i,a,s,d;return i=new Et({props:{$$slots:{default:[ne]},$$scope:{ctx:g}}}),s=new Lt({props:{$$slots:{default:[ie]},$$scope:{ctx:g}}}),{c(){V(i.$$.fragment),a=_(),V(s.$$.fragment)},l(t){z(i.$$.fragment,t),a=w(t),z(s.$$.fragment,t)},m(t,r){N(i,t,r),u(t,a,r),N(s,t,r),d=!0},p(t,r){const I={};r&8&&(I.$$scope={dirty:r,ctx:t}),i.$set(I);const y={};r&8&&(y.$$scope={dirty:r,ctx:t}),s.$set(y)},i(t){d||(Y(i.$$.fragment,t),Y(s.$$.fragment,t),d=!0)},o(t){O(i.$$.fragment,t),O(s.$$.fragment,t),d=!1},d(t){F(i,t),t&&n(a),F(s,t)}}}function le(g){let i;return{c(){i=c("Quantum Computing (TBC)")},l(a){i=p(a,"Quantum Computing (TBC)")},m(a,s){u(a,i,s)},d(a){a&&n(i)}}}function ae(g){let i,a,s,d,t,r,I,y,E,A,C,L,Q,D,q,U,e,h,G,R,P,x,K,o,k,Z,H,tt,et,W,rt,ut,X,ft,mt,S,nt,ct,it,st,b,T,lt,pt,$t,B,dt,ht,at,vt,_t,ot,wt,bt,yt,qt,Pt,It,At;return{c(){i=f("br"),a=c(`
			I'm currently training to take the `),s=f("a"),d=c("IBM Quantum Developer Certification"),t=c(`.
			I expect to take the exam in summer 2023. `),r=f("br"),I=_(),y=f("br"),E=c(`
			I've been a user of quantum mechanics since 2015; I studied it during my undergraduate, I used it to derive well known formulae
			in magnetism during my Masters and I regularly use it in my PhD to come up with expressions for material specific dispersion relations
			and calculate expectation values at finite temperature – even my classical simulations use quantum statistics to calculate
			the strength of stochastic thermal fields (see `),A=f("a"),C=c("here"),L=c(`
			for the original paper). `),Q=f("br"),D=_(),q=f("br"),U=c(`
			I also understand quantum information and quantum computing very well. I studied the foundations of quantum information during my
			undergraduate and masters. In my undergraduate I learnt how photonics components are used with single photon sources to apply
			different quantum operations on the polarisation of a photon. In my masters, I used learnt about classical information and communication
			theory including:
			`),e=f("ul"),h=f("li"),G=c("Universal computation"),R=_(),P=f("li"),x=c("Shannon and Von Neumann entropy"),K=_(),o=f("li"),k=c("Quantum circuits using Qiskit"),Z=_(),H=f("li"),tt=c("The density matrix (and decoherence in quantum systems)"),et=_(),W=f("li"),rt=c("Measurement of multiqubit states"),ut=_(),X=f("li"),ft=c("Algorithms"),mt=_(),S=f("ul"),nt=f("li"),ct=c("Shor's"),it=_(),st=f("li"),b=c("Grover's search"),T=_(),lt=f("li"),pt=c("Deutsch's"),$t=_(),B=f("li"),dt=c("Teleportation"),ht=_(),at=f("li"),vt=c("Quantum Hamming code (error correction)"),_t=_(),ot=f("li"),wt=c("Quantum key distribution (and how it prevents common classical attacks)"),bt=_(),yt=f("li"),qt=c("The effect of unobserved degrees of freedom"),Pt=_(),It=f("li"),At=c("DiVincenzo's criteria"),this.h()},l($){i=m($,"BR",{}),a=p($,`
			I'm currently training to take the `),s=m($,"A",{href:!0});var M=v(s);d=p(M,"IBM Quantum Developer Certification"),M.forEach(n),t=p($,`.
			I expect to take the exam in summer 2023. `),r=m($,"BR",{}),I=w($),y=m($,"BR",{}),E=p($,`
			I've been a user of quantum mechanics since 2015; I studied it during my undergraduate, I used it to derive well known formulae
			in magnetism during my Masters and I regularly use it in my PhD to come up with expressions for material specific dispersion relations
			and calculate expectation values at finite temperature – even my classical simulations use quantum statistics to calculate
			the strength of stochastic thermal fields (see `),A=m($,"A",{href:!0});var Dt=v(A);C=p(Dt,"here"),Dt.forEach(n),L=p($,`
			for the original paper). `),Q=m($,"BR",{}),D=w($),q=m($,"BR",{}),U=p($,`
			I also understand quantum information and quantum computing very well. I studied the foundations of quantum information during my
			undergraduate and masters. In my undergraduate I learnt how photonics components are used with single photon sources to apply
			different quantum operations on the polarisation of a photon. In my masters, I used learnt about classical information and communication
			theory including:
			`),e=m($,"UL",{});var j=v(e);h=m(j,"LI",{});var St=v(h);G=p(St,"Universal computation"),St.forEach(n),R=w(j),P=m(j,"LI",{});var Rt=v(P);x=p(Rt,"Shannon and Von Neumann entropy"),Rt.forEach(n),K=w(j),o=m(j,"LI",{});var Tt=v(o);k=p(Tt,"Quantum circuits using Qiskit"),Tt.forEach(n),Z=w(j),H=m(j,"LI",{});var Ct=v(H);tt=p(Ct,"The density matrix (and decoherence in quantum systems)"),Ct.forEach(n),et=w(j),W=m(j,"LI",{});var Qt=v(W);rt=p(Qt,"Measurement of multiqubit states"),Qt.forEach(n),ut=w(j),X=m(j,"LI",{});var Ut=v(X);ft=p(Ut,"Algorithms"),Ut.forEach(n),mt=w(j),S=m(j,"UL",{});var J=v(S);nt=m(J,"LI",{});var Gt=v(nt);ct=p(Gt,"Shor's"),Gt.forEach(n),it=w(J),st=m(J,"LI",{});var Mt=v(st);b=p(Mt,"Grover's search"),Mt.forEach(n),T=w(J),lt=m(J,"LI",{});var jt=v(lt);pt=p(jt,"Deutsch's"),jt.forEach(n),$t=w(J),B=m(J,"LI",{});var xt=v(B);dt=p(xt,"Teleportation"),xt.forEach(n),ht=w(J),at=m(J,"LI",{});var Ht=v(at);vt=p(Ht,"Quantum Hamming code (error correction)"),Ht.forEach(n),_t=w(J),ot=m(J,"LI",{});var Vt=v(ot);wt=p(Vt,"Quantum key distribution (and how it prevents common classical attacks)"),Vt.forEach(n),J.forEach(n),bt=w(j),yt=m(j,"LI",{});var zt=v(yt);qt=p(zt,"The effect of unobserved degrees of freedom"),zt.forEach(n),Pt=w(j),It=m(j,"LI",{});var Nt=v(It);At=p(Nt,"DiVincenzo's criteria"),Nt.forEach(n),j.forEach(n),this.h()},h(){gt(s,"href","https://www.ibm.com/blogs/research/2021/03/quantum-developer-certification/"),gt(A,"href","https://eprints.whiterose.ac.uk/151412/1/quantum_thermodynamics_of_yig_merged.pdf")},m($,M){u($,i,M),u($,a,M),u($,s,M),l(s,d),u($,t,M),u($,r,M),u($,I,M),u($,y,M),u($,E,M),u($,A,M),l(A,C),u($,L,M),u($,Q,M),u($,D,M),u($,q,M),u($,U,M),u($,e,M),l(e,h),l(h,G),l(e,R),l(e,P),l(P,x),l(e,K),l(e,o),l(o,k),l(e,Z),l(e,H),l(H,tt),l(e,et),l(e,W),l(W,rt),l(e,ut),l(e,X),l(X,ft),l(e,mt),l(e,S),l(S,nt),l(nt,ct),l(S,it),l(S,st),l(st,b),l(S,T),l(S,lt),l(lt,pt),l(S,$t),l(S,B),l(B,dt),l(S,ht),l(S,at),l(at,vt),l(S,_t),l(S,ot),l(ot,wt),l(e,bt),l(e,yt),l(yt,qt),l(e,Pt),l(e,It),l(It,At)},p:Bt,d($){$&&n(i),$&&n(a),$&&n(s),$&&n(t),$&&n(r),$&&n(I),$&&n(y),$&&n(E),$&&n(A),$&&n(L),$&&n(Q),$&&n(D),$&&n(q),$&&n(U),$&&n(e)}}}function oe(g){let i,a,s,d;return i=new Et({props:{$$slots:{default:[le]},$$scope:{ctx:g}}}),s=new Lt({props:{$$slots:{default:[ae]},$$scope:{ctx:g}}}),{c(){V(i.$$.fragment),a=_(),V(s.$$.fragment)},l(t){z(i.$$.fragment,t),a=w(t),z(s.$$.fragment,t)},m(t,r){N(i,t,r),u(t,a,r),N(s,t,r),d=!0},p(t,r){const I={};r&8&&(I.$$scope={dirty:r,ctx:t}),i.$set(I);const y={};r&8&&(y.$$scope={dirty:r,ctx:t}),s.$set(y)},i(t){d||(Y(i.$$.fragment,t),Y(s.$$.fragment,t),d=!0)},o(t){O(i.$$.fragment,t),O(s.$$.fragment,t),d=!1},d(t){F(i,t),t&&n(a),F(s,t)}}}function re(g){let i;return{c(){i=c("Programming")},l(a){i=p(a,"Programming")},m(a,s){u(a,i,s)},d(a){a&&n(i)}}}function ue(g){let i,a,s,d,t,r,I,y,E,A,C,L,Q,D,q,U,e,h,G,R,P,x,K,o,k,Z,H,tt,et,W,rt,ut,X,ft,mt,S,nt,ct,it,st;return{c(){i=f("br"),a=c(`
			Aside from scientific computing, I have a range of personal projects as well. Most of the associated GitHub repos are private, but I've listed some of the more interesting
			ones here:
			`),s=f("ul"),d=f("li"),t=c("A stock screener written in Python and uses my own algorithms to determine the value of an asset."),r=_(),I=f("li"),y=c("Solutions to quantum problems using the quantum Python libraries Qiskit and Q#."),E=_(),A=f("li"),C=c("A web3 app written in Rust."),L=c(`
			I love using programming as a tool to make useful applications that automate tasks, scale calculations beyond what is humanly capable, and creating minimalist and intuitive visualisations and user interfaces. `),Q=f("br"),D=_(),q=f("br"),U=c(`
			Here are some of the tools and programming languages I've used to make projects:
			`),e=f("ul"),h=f("li"),G=c("C++"),R=_(),P=f("li"),x=c("CUDA"),K=_(),o=f("li"),k=c("Python"),Z=_(),H=f("li"),tt=c("Git"),et=_(),W=f("li"),rt=c("Rust"),ut=_(),X=f("li"),ft=c("Svelte"),mt=_(),S=f("li"),nt=c("BASH"),ct=_(),it=f("li"),st=c("CMake")},l(b){i=m(b,"BR",{}),a=p(b,`
			Aside from scientific computing, I have a range of personal projects as well. Most of the associated GitHub repos are private, but I've listed some of the more interesting
			ones here:
			`),s=m(b,"UL",{});var T=v(s);d=m(T,"LI",{});var lt=v(d);t=p(lt,"A stock screener written in Python and uses my own algorithms to determine the value of an asset."),lt.forEach(n),r=w(T),I=m(T,"LI",{});var pt=v(I);y=p(pt,"Solutions to quantum problems using the quantum Python libraries Qiskit and Q#."),pt.forEach(n),E=w(T),A=m(T,"LI",{});var $t=v(A);C=p($t,"A web3 app written in Rust."),$t.forEach(n),T.forEach(n),L=p(b,`
			I love using programming as a tool to make useful applications that automate tasks, scale calculations beyond what is humanly capable, and creating minimalist and intuitive visualisations and user interfaces. `),Q=m(b,"BR",{}),D=w(b),q=m(b,"BR",{}),U=p(b,`
			Here are some of the tools and programming languages I've used to make projects:
			`),e=m(b,"UL",{});var B=v(e);h=m(B,"LI",{});var dt=v(h);G=p(dt,"C++"),dt.forEach(n),R=w(B),P=m(B,"LI",{});var ht=v(P);x=p(ht,"CUDA"),ht.forEach(n),K=w(B),o=m(B,"LI",{});var at=v(o);k=p(at,"Python"),at.forEach(n),Z=w(B),H=m(B,"LI",{});var vt=v(H);tt=p(vt,"Git"),vt.forEach(n),et=w(B),W=m(B,"LI",{});var _t=v(W);rt=p(_t,"Rust"),_t.forEach(n),ut=w(B),X=m(B,"LI",{});var ot=v(X);ft=p(ot,"Svelte"),ot.forEach(n),mt=w(B),S=m(B,"LI",{});var wt=v(S);nt=p(wt,"BASH"),wt.forEach(n),ct=w(B),it=m(B,"LI",{});var bt=v(it);st=p(bt,"CMake"),bt.forEach(n),B.forEach(n)},m(b,T){u(b,i,T),u(b,a,T),u(b,s,T),l(s,d),l(d,t),l(s,r),l(s,I),l(I,y),l(s,E),l(s,A),l(A,C),u(b,L,T),u(b,Q,T),u(b,D,T),u(b,q,T),u(b,U,T),u(b,e,T),l(e,h),l(h,G),l(e,R),l(e,P),l(P,x),l(e,K),l(e,o),l(o,k),l(e,Z),l(e,H),l(H,tt),l(e,et),l(e,W),l(W,rt),l(e,ut),l(e,X),l(X,ft),l(e,mt),l(e,S),l(S,nt),l(e,ct),l(e,it),l(it,st)},p:Bt,d(b){b&&n(i),b&&n(a),b&&n(s),b&&n(L),b&&n(Q),b&&n(D),b&&n(q),b&&n(U),b&&n(e)}}}function fe(g){let i,a,s,d;return i=new Et({props:{$$slots:{default:[re]},$$scope:{ctx:g}}}),s=new Lt({props:{$$slots:{default:[ue]},$$scope:{ctx:g}}}),{c(){V(i.$$.fragment),a=_(),V(s.$$.fragment)},l(t){z(i.$$.fragment,t),a=w(t),z(s.$$.fragment,t)},m(t,r){N(i,t,r),u(t,a,r),N(s,t,r),d=!0},p(t,r){const I={};r&8&&(I.$$scope={dirty:r,ctx:t}),i.$set(I);const y={};r&8&&(y.$$scope={dirty:r,ctx:t}),s.$set(y)},i(t){d||(Y(i.$$.fragment,t),Y(s.$$.fragment,t),d=!0)},o(t){O(i.$$.fragment,t),O(s.$$.fragment,t),d=!1},d(t){F(i,t),t&&n(a),F(s,t)}}}function me(g){let i,a,s,d,t,r,I,y,E,A,C,L,Q,D,q,U;return i=new Kt({props:{image_url:ce}}),s=new Wt({}),r=new kt({props:{square:!0,elevation:"4",color:"secondary",$$slots:{default:[ee]},$$scope:{ctx:g}}}),E=new kt({props:{square:!0,elevation:"4",style:g[0],$$slots:{default:[se]},$$scope:{ctx:g}}}),L=new kt({props:{square:!0,elevation:"4",style:g[0],$$slots:{default:[oe]},$$scope:{ctx:g}}}),q=new kt({props:{square:!0,elevation:"4",style:g[0],$$slots:{default:[fe]},$$scope:{ctx:g}}}),{c(){V(i.$$.fragment),a=_(),V(s.$$.fragment),d=_(),t=f("div"),V(r.$$.fragment),I=_(),y=f("div"),V(E.$$.fragment),A=_(),C=f("div"),V(L.$$.fragment),Q=_(),D=f("div"),V(q.$$.fragment)},l(e){z(i.$$.fragment,e),a=w(e),z(s.$$.fragment,e),d=w(e),t=m(e,"DIV",{});var h=v(t);z(r.$$.fragment,h),h.forEach(n),I=w(e),y=m(e,"DIV",{});var G=v(y);z(E.$$.fragment,G),G.forEach(n),A=w(e),C=m(e,"DIV",{});var R=v(C);z(L.$$.fragment,R),R.forEach(n),Q=w(e),D=m(e,"DIV",{});var P=v(D);z(q.$$.fragment,P),P.forEach(n)},m(e,h){N(i,e,h),u(e,a,h),N(s,e,h),u(e,d,h),u(e,t,h),N(r,t,null),u(e,I,h),u(e,y,h),N(E,y,null),u(e,A,h),u(e,C,h),N(L,C,null),u(e,Q,h),u(e,D,h),N(q,D,null),U=!0},p(e,[h]){const G={};h&8&&(G.$$scope={dirty:h,ctx:e}),r.$set(G);const R={};h&8&&(R.$$scope={dirty:h,ctx:e}),E.$set(R);const P={};h&8&&(P.$$scope={dirty:h,ctx:e}),L.$set(P);const x={};h&8&&(x.$$scope={dirty:h,ctx:e}),q.$set(x)},i(e){U||(Y(i.$$.fragment,e),Y(s.$$.fragment,e),Y(r.$$.fragment,e),Y(E.$$.fragment,e),Y(L.$$.fragment,e),Y(q.$$.fragment,e),U=!0)},o(e){O(i.$$.fragment,e),O(s.$$.fragment,e),O(r.$$.fragment,e),O(E.$$.fragment,e),O(L.$$.fragment,e),O(q.$$.fragment,e),U=!1},d(e){F(i,e),e&&n(a),F(s,e),e&&n(d),e&&n(t),F(r),e&&n(I),e&&n(y),F(E),e&&n(A),e&&n(C),F(L),e&&n(Q),e&&n(D),F(q)}}}const ce="/images/diy.jpg";let pe="background-color: var(--mdc-theme-background, #f8f8f8);";function $e(g,i,a){let s;Jt(g,Xt,r=>a(1,s=r));let d;return[s?d:pe]}class be extends Yt{constructor(i){super(),Ot(this,i,$e,me,Ft,{})}}export{be as default};
